#' Plot NetLogo World Patches
#'
#' @description
#'
#' `r lifecycle::badge("experimental")`
#'
#' `plot_patches()` visualizes the state of NetLogo patches at a specific run
#' and step. Patches are rendered based on their `pcolor` attribute, providing
#' a spatial snapshot of the environment.
#'
#' This function serves as a foundational layer for NetLogo World
#' visualizations. Users can extend the resulting plot by adding layers for
#' turtles, links, or other [`ggplot2`](https://ggplot2.tidyverse.org/)
#' components to match their specific requirements.
#'
#' @details
#'
#' To use this function, your experiment must collect specific patch data
#' and the "lists" output. Ensure the following reporters are included in the
#' `metrics` argument of [`create_experiment()`][create_experiment()]:
#'
#' - `[pxcor] of patches`
#' - `[pycor] of patches`
#' - `[pcolor] of patches`
#'
#' These metrics must be available within the `lists` output of
#' [`run_experiment()`][run_experiment()].
#'
#' @param data A tidy [`tibble`][tibble::tibble()] containing experiment results
#'   of type `lists`, as generated by [`run_experiment()`][run_experiment()].
#'   This tibble must include the required patch metrics: `[pxcor] of patches`,
#'   `[pycor] of patches`, and `[pcolor] of patches`. Refer to the *Details*
#'   section for additional context.
#' @param na_value (optional) A [`character`][base::as.character()] string
#'   indicating and hexadecimal color value to use for patches with missing
#'   `pcolor` values (default: `"#BFBFBF"`).
#'
#' @return A [`ggplot2`][ggplot2::ggplot()] object representing the NetLogo
#'   world patches at the specified run and step.
#'
#' @family plot functions
#' @export
#'
#' @examples
#' # Loading Packages -----
#'
#' \dontrun{
#'   library(ggplot2)
#'   library(ggimage)
#'   library(magrittr)
#'   library(stringr)
#'   library(tidyr)
#' }
#'
#' # Defining the Model -----
#'
#' \dontrun{
#'   model_path <- # This model is included with NetLogo installations.
#'     find_netlogo_home() |>
#'     file.path(
#'       "models",
#'       "Sample Models",
#'       "Biology",
#'       "Wolf Sheep Predation.nlogox"
#'     )
#' }
#'
#' # Creating an Experiment -----
#'
#' \dontrun{
#'   setup_file <- create_experiment(
#'     name = "Agent Attributes Extraction",
#'     repetitions = 1,
#'     sequential_run_order = TRUE,
#'     run_metrics_every_step = TRUE,
#'     time_limit = 1,
#'     metrics = c(
#'       '[who] of sheep',
#'       '[xcor] of sheep',
#'       '[ycor] of sheep',
#'       '[shape] of sheep',
#'       '[color] of sheep',
#'       '[who] of wolves',
#'       '[xcor] of wolves',
#'       '[ycor] of wolves',
#'       '[shape] of wolves',
#'       '[color] of wolves',
#'       '[pxcor] of patches',
#'       '[pycor] of patches',
#'       '[pcolor] of patches'
#'     ),
#'     constants = list(
#'       "model-version" = "sheep-wolves-grass"
#'     )
#'   )
#' }
#'
#' # Running the Experiment -----
#'
#' \dontrun{
#'   results <-
#'     model_path |>
#'     run_experiment(
#'       setup_file = setup_file,
#'       outputs = c("table", "lists")
#'     )
#' }
#'
#' # Preparing Plot Data -----
#'
#' \dontrun{
#'  plot_data <-
#'    results |>
#'    extract2("lists") |>
#'    dplyr::filter(run_number == 1, step == 0)
#' }
#'
#' # Visualizing Patches -----
#'
#' \dontrun{
#'   plot_data |> plot_patches()
#' }
#'
#' # Getting Agents Shapes -----
#'
#' \dontrun{
#'   turtle_shapes <-
#'     system.file("extdata", package = "logolink") |>
#'     list.files(full.names = TRUE)
#' }
#'
#' # Adding Agents to the Plot -----
#'
#' \dontrun{
#'   plot_data |>
#'     plot_patches() +
#'     geom_image(
#'       data = plot_data |>
#'         drop_na(xcor_of_sheep),
#'       mapping = aes(
#'         x = xcor_of_sheep,
#'         y = ycor_of_sheep,
#'         image = turtle_shapes |>
#'           str_subset("sheep") |>
#'           head(1)
#'       ),
#'       size = 0.035
#'     ) +
#'     geom_image(
#'       data = plot_data |>
#'         drop_na(xcor_of_wolves),
#'       mapping = aes(
#'         x = xcor_of_wolves,
#'         y = ycor_of_wolves,
#'         image = turtle_shapes |>
#'           str_subset("wolf") |>
#'           head(1)
#'       ),
#'       size = 0.04
#'     )
#' }
plot_patches <- function(
  data,
  na_value = parse_netlogo_color(7.5)
) {
  require_pkg("ggplot2")

  checkmate::assert_tibble(data)
  checkmate::assert_subset(c("run_number", "step"), colnames(data))
  checkmate::assert_string(na_value, pattern = "^#[0-9a-fA-F]{6}$")

  # R CMD Check variable bindings fix.
  # nolint start
  .env <- pxcor_of_patches <- pycor_of_patches <- pcolor_of_patches <- NULL
  # nolint end

  patches_metrics <- c(
    '[pxcor] of patches' = "pxcor_of_patches",
    '[pycor] of patches' = "pycor_of_patches",
    '[pcolor] of patches' = "pcolor_of_patches"
  )

  if (!all(patches_metrics %in% colnames(data))) {
    cli::cli_abort(
      paste0(
        "The data provided do not contain all required patch metrics. ",
        "Add the following metrics to your results before using this ",
        "function: ",
        "{.strong {cli::col_red(names(patches_metrics))}}."
      )
    )
  }

  if (
    (length(unique(data$run_number)) > 1) ||
      (length(unique(data$step)) > 1)
  ) {
    cli::cli_abort(
      "The data provided contain multiple run numbers or steps. Please filter ",
      "the data to a single run number and step before using this function."
    )
  }

  data <-
    data |>
    dplyr::mutate(
      dplyr::across(
        .cols = dplyr::matches("^pcolor_of_patches|^color_of_"),
        .fns = parse_netlogo_color
      )
    )

  data |>
    ggplot2::ggplot(
      ggplot2::aes(
        x = pxcor_of_patches,
        y = pycor_of_patches,
        fill = pcolor_of_patches
      )
    ) +
    ggplot2::geom_raster() +
    ggplot2::coord_fixed() +
    ggplot2::scale_x_continuous(expand = c(0, 0)) +
    ggplot2::scale_y_continuous(expand = c(0, 0)) +
    ggplot2::scale_fill_identity(
      na.value = na_value
    ) +
    ggplot2::theme_void() +
    ggplot2::theme(
      legend.position = "none"
    )
}
